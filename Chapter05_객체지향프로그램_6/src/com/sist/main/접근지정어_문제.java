package com.sist.main;
public class Member
{
	String name;
	String id;
	String password;
	int age;
}

public class 접근지정어_문제 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//				1. 객체와 클래스에 대한 설명으로 틀린 것은 무엇입니까? 3/3
//				1) 클래스는 객체를 생성하기 위한 설계도(청사진)와 같은 것이다.
		           ---- 설계
		                자재 => 변수
		                기술 => 메소드
//				2) new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다.
		             클래스 객체명=new 생성자();
		             ---------------------
		             Class className=Class.forNmae=> 리플렉션 => 객체 생성
		             => 메소드 멤버변수 생성자 전부다 제어가 가능
//				3) 하나의 클래스로 하나의 객체만 생성할 수 있다.
		            new를 사용하면 객체는 언제든 생성이 가능하다
		            class 1개에 여러개의 객체를 생성이 가능하다
//				4) 객체는 클래스의 인스턴스이다.
		                   추상화(실무는:요구사항분석) => 공통된 부분을 추출
		             객체 사물 => class ClassName => 컴퓨터에 저장 된 상태를 인스턴스라고 부른다
		                                           new Sawon()
		             사원/회원	{
		            	      String name
		            	      String 부서
		             	    }
//
//				2. 클래스의 구성 멤버가 아닌 것은 무엇입니까? 4/4
//				1) 필드(field) = 멤버변수 = 초기값을 가지고 있다.
//				2) 생성자(constructor)
		             맴버 변수의 초기화를 담당하고 /객체 생성시에 호출 역할 / 시작과 동시에 처리하는 기능이 있을때 주로 사용한다.
		             윈도우 : 레이아웃(화면UI) 
		             특징
		                1. 클래스명과 동일 2.리턴형이 없다 3.다른 클래스에서 사용 4.오버로딩이 가능해서 여러개를 만들 수 있다. 위 것들이 생성자가 하는 역할이다.
//				3) 메소드(method):멤버변수를 이용한 데이터 관리(기능)
		                =>다른 클래스와 통신(메세지) / 오버로딩
		                =>리턴형 : 실행결과값 => 1개만 사용 가능하다
		                =>사용자가 요청한 값 : 여러개를 사용 가능 = 매개변수 라고 말한다
//				4) 로컬 변수(local variable)
		             로컬변수는 메소드나 생성자 안에서 사용되는 것으로 없어도 상관없다. {}이 종료되면 사라지는 변수이다.
		              => 초기값이 없다.
//
//				3. 필드, 생성자, 메소드에 대한 설명으로 틀린 것은 무엇입니까? 4/4
//				1) 필드는 객체의 데이터를 저장한다. : 변수(데이터 저장 공간)
//				2) 생성자는 객체의 초기화를 담당한다.
//				3) 메소드는 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
//				4) 클래스는 반드시 필드와 메소드를 가져야 한다.
		              =>멤버변수만 가지고 있는것 : 사용자 정의 테이터형 = VO = DTO 로 불리기도 한다
		              =>메소드만 가지고 있는것 : 액션 클래스 = DAO=MODEL
		              =>변수+메소드 통합한 것 : 일반 클래스
//
//				4. 필드에 대한 설명으로 틀린 것은 무엇입니까? 3/3
//				1) 필드는 메소드에서 사용할 수 있다. 멤버변수는 class영역 / 다른 클래스에서도 사용이 가능
//				2) 인스턴스 필드 초기화는 생성자에서 할 수 있다.
		              => 명시적 초기화
		              => 생성자
		              => 인스턴스 초기화 블록
		              Class A
		              {
		            	  	int=a10; 명시적 초기화
		            	  	A()생성자
		            	  	{
		            	  		a=100;
		            	  	}
		            	  	{
		            	  		a=1000; 인스턴스 초기화 블록
		            	  	}
		              }
//				3) 필드는 반드시 생성자 선언 전에 선언되어야 한다.
		              => 순서는 상관없다
//				4) 필드는 초기값을 주지 않더라고 기본값으로 자동 초기화된다.
		             =>멤버변수는 자동 초기화가 된다.
//
//				5. 생성자에 대한 설명으로 틀린 것은 무엇입니까? 1/1
//				1) 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다.
//				2) 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
		             this()=> 자신의 생성자 호출
		             => 생성자안에서만 호출 가능
		             => 생성자안에서 첫번째줄에서 사용
//				3) 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다.
		             Class A생성자가 하나도 없어야 한다/ 매개변수도 하나의 생성자이다.
		             {
		            	 A{}=> 생성자 존재
		             }
		             Class A
		             {
		            	 A(int a)()생성자 존재
		             }
		             Class A
		             {
		            	 A(){} 이게 자동생성해주는 것
		             }
//				4) 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
                  생성자 : defualt,public,protected,private
		             
//				6. 메소드에 대한 설명으로 틀린 것은 무엇입니까? 4/4
                  리턴형 매개변수
                    o    o
                    o    x
                    x    o
                    x    x
//				1) 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다.
//				2) 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.
//				3) 매개값의 수를 모를 경우 "..."를 이용해서 매개 변수를 선언할 수 있다.
                                      가변매개 변수
//				4) 메소드의 이름은 중복해서 선언할 수 없다.(중복 메소드 정의가 가능 => 오버로딩)
//
//				7. 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까? 3/2
//				1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
//				2) 반드시 리턴 타입이 달라야 한다.
                    리턴형은 관계없다.
//				3) 매개 변수의 타입, 수 순서를 다르게 선언해야 한다.
//				4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다.
                    => 맞는 데이터형 => 유사 데이터형
//
//				8. 인스턴스 멤버와 정적 멤버에 대한 설명으로 틀린 것은 무엇입니까? 3/2
//				1) 정적 멤버는 static으로 선언된 필드와 메소드를 말한다.
//				2) 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다.
                                      ----- static만 사용이 가능 이 부분만 틀렸다.
//				3) 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.
                    클래스명.변수명 , 클래스명.메소드
//				4) 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다. 
                    
//
//				9. final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까? 4
//				1) final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
//				2) final 필드와 상수는 생성자에서 초기화될 수 있다.
//				3) 상수의 이름은 대문자로 작성하는 것이 관례이다.
//				4) 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.
//
//				10. 다음 클래스에서 해당 멤버가 필드, 생성자, 메소드 중 어떤 것인지 빈칸을 채우세요.
//				1
//				2
//				3
//				4
//				5
//				6
//				7	public class Member {
//				    private String name; // -------------------------------------(  (1)  )  필드
//				 
//				    public Member(String name) { } // ---------------------------(  (2)  )   생성자
//				    
//				    public void setName(String name) { } // ---------------------(  (3)  ) 메소드
//				}
//				Colored by Color Scripter
//				cs
//
//				11. 현실 세계의 회원을 Member 클래스로 모델링하려고 합니다. 회원의 데이터로는 이름, 아이디, 패스워드, 나이가 있습니다. 이 데이터들을 가지는 Member 클래스를 선언해보세요.
//				 데이터 이름	 필드 이름 	 타입 
//				 이름 	 name 	 문자열 
//				 아이디	 id	 문자열 
//				 패스워드	 password	 문자열 
//				 나이	 age	 정수 
//
//				12. 위에서 작성한 Member 클래스에 생성자를 추가하려고 합니다. 다음과 같이 Member 객체를 생성할 때 name 필드와 id 필드를 외부에서 받은 값으로 초기화하려면 생성자를 어떻게 선언해야 합니까?
				Member name=new Member();
				Member id=new Member();

	}

}
